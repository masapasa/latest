[
  {
    "objectID": "til/code_review.html",
    "href": "til/code_review.html",
    "title": "The Code Review Pyramid",
    "section": "",
    "text": "This is a graphic written by Gunnar Morling on what is described as the “Code Review Pyramid.” It’s split into five “layers” that I’ll quickly describe."
  },
  {
    "objectID": "til/sub_cli.html",
    "href": "til/sub_cli.html",
    "title": "Creating Nested CLI Commands with argparse",
    "section": "",
    "text": "For the accelerate library we have a variety of commands, such as accelerate config, accelerate launch, etc. However I noticed that some functionality was wanted to write a default config file.\nOn one hand, I could just do accelerate config --default. But then I’d have to deal with the fact that config is a Q/A interface that doesn’t take parameters, and --default should.\nI wanted accelerate config default, and I had to use argparse to get there"
  },
  {
    "objectID": "til/sub_cli.html#the-code",
    "href": "til/sub_cli.html#the-code",
    "title": "Creating Nested CLI Commands with argparse",
    "section": "The Code",
    "text": "The Code\n\nCodeCode + Explanation\n\n\n\n\n\n__init__.py\n\n# import argparse\n\n# from command_1 import command_arg_parser\n# from command_2 import subcommand_arg_parser\n\n# def get_command_parser(subparsers=None):\n#     # Create a base parser to link everything together\n#     parent_parser = argparse.ArgumentParser(add_help=False)\n#     # Create a main parser that will be the driver\n#     command_parser = command_arg_parser(subparsers)\n#     # Create a subcommand driver\n#     subcommands = command_parser.add_subparsers(\n#         title=\"subcommands\", \n#         dest=\"subcommand\"\n#     )\n    \n#     # Add the other parsers\n#     subcommand_arg_parser(\n#         subcommands, \n#         parents=[parent_parser]\n#     )\n#     return command_parser\n\n# def main():\n#     parser = get_command_parser()\n#     args = parser.parse_args()\n    \n# if __name__ == \"__main__\":\n#     main()\n\n\n\n\n\n\n\n__init__.py\n\n# import argparse\n\n# from command_1 import command_arg_parser\n# from command_2 import subcommand_arg_parser\n\n# def get_command_parser(subparsers=None):\n#     # Create a base parser to link everything together\n#     parent_parser = argparse.ArgumentParser(add_help=False)\n#     # Create a main parser that will be the driver\n#     command_parser = command_arg_parser(subparsers)\n#     # Create a subcommand driver\n#     subcommands = command_parser.add_subparsers(\n#         title=\"subcommands\", \n#         dest=\"subcommand\"\n#     )\n    \n#     # Add the other parsers\n#     subcommand_arg_parser(\n#         subcommands, \n#         parents=[parent_parser]\n#     )\n#     return command_parser\n\n# def main():\n#     parser = get_command_parser()\n#     args = parser.parse_args()\n    \n# if __name__ == \"__main__\":\n#     main()\n\n\n\n from command_1 import command_arg_parser\n# from command_2 import subcommand_arg_parser\n\nEach command part will have its own function that returns an argument parser\n\n\n def get_command_parser(subparsers=None):\n\nSimilarly we create a function that will return a new parser\n\n\n     parent_parser = argparse.ArgumentParser(add_help=False)\n\nThis will be the “base” parser that will tie everything together. Nothing will get explicitly added here but it will act as the parent for all subcommands\n\n\n     command_parser = command_arg_parser(subparsers)\n\nThis will be our main driver parser.\n\n\n     subcommands = command_parser.add_subparsers(\n#         title=\"subcommands\", \n#         dest=\"subcommand\"\n#     )\n\nThis subparser will contain all the subcommands in the style of command_parser_command subcommand\n\n\n     subcommand_arg_parser(\n#         subcommands, \n#         parents=[parent_parser]\n#     )\n\nWe then add the subcommands subparser to the command_arg_parser and pass in the parent_parser as the parents for that parser. (This will make sense in a moment)\n\n\n\n\n\nCodeCode + Explanation\n\n\n\n\n\ncommand_1.py\n\nimport argparse\n\ndef command_arg_parser(subparsers=None):\n    if subparsers is not None:\n        parser = subparsers.add_parser(\"command_1\", description=\"The first command\")\n    else:\n        parser = argparse.ArgumentParser(\"Command 1\", description=\"The first command\")\n    \n    parser.add_argument(\n        \"--do-the-thing\",\n        default=None,\n        help=\"Whether to do the thing\"\n    )\n    if subparsers is not None:\n        parser.set_defaults(func=command_func)\n    return parser\n\ndef command_func(args):\n    print(args)\n\n\n\n\n\n\n\ncommand_1.py\n\nimport argparse\n\ndef command_arg_parser(subparsers=None):\n    if subparsers is not None:\n        parser = subparsers.add_parser(\"command_1\", description=\"The first command\")\n    else:\n        parser = argparse.ArgumentParser(\"Command 1\", description=\"The first command\")\n    \n    parser.add_argument(\n        \"--do-the-thing\",\n        default=None,\n        help=\"Whether to do the thing\"\n    )\n    if subparsers is not None:\n        parser.set_defaults(func=command_func)\n    return parser\n\ndef command_func(args):\n    print(args)\n\n\n\ndef command_arg_parser(subparsers=None):\n    if subparsers is not None:\n        parser = subparsers.add_parser(\"command_1\", description=\"The first command\")\n    else:\n        parser = argparse.ArgumentParser(\"Command 1\", description=\"The first command\")\n\nWe create a new command_arg_parser function that will either add a new parser to the passed in subparser or a new one in general. This is extremely important\n\n\n    parser.add_argument(\n        \"--do-the-thing\",\n        default=None,\n        help=\"Whether to do the thing\"\n    )\n\nThen add in arguments like normal\n\n\n    if subparsers is not None:\n        parser.set_defaults(func=command_func)\n    return parser\n\nSet the defaults for the particular parser to be that of the function we intend to call\n\n\ndef command_func(args):\n    print(args)\n\nThe function that will be ran with this particular command, to keep the code clean. Accepts some argument namespace.\n\n\n\n\nAnd finally create the last subcommand:\n\nCodeCode + Explanation\n\n\n\n\n\ncommand_2.py\n\n# import argparse\n# from .utils import SubcommandHelpFormatter\n\n# def subcommand_arg_parser(parser, parents):\n#     parser = parser.add_parser(\n#         \"command_2\", \n#         parents=parents, \n#         help=\"Command 2 help\", \n#         formatter_class=SubcommandHelpFormatter\n#     )\n#     parser.add_argument(\n#         \"--do-another-thing\",\n#         default=None,\n#         help=\"Whether to do the other thing\"\n#     )\n#     parser.set_defaults(func=subcommand_func)\n#     return parser\n\n# def subcommand_func(args):\n#     print(args)\n\n\nImportError: attempted relative import with no known parent package\n\n\n\n\n\n\n\ncommand_2.py\n\n# import argparse\n# from .utils import SubcommandHelpFormatter\n\n# def subcommand_arg_parser(parser, parents):\n#     parser = parser.add_parser(\n#         \"command_2\", \n#         parents=parents, \n#         help=\"Command 2 help\", \n#         formatter_class=SubcommandHelpFormatter\n#     )\n#     parser.add_argument(\n#         \"--do-another-thing\",\n#         default=None,\n#         help=\"Whether to do the other thing\"\n#     )\n#     parser.set_defaults(func=subcommand_func)\n#     return parser\n\n# def subcommand_func(args):\n#     print(args)\n\n\nImportError: attempted relative import with no known parent package\n\n\n\n def subcommand_arg_parser(parser, parents):\n\nThis function should take in both a parser and the parents for the parser. The latter will help link everything together\n\n\n     parser = parser.add_parser(\n#         \"command_2\", \n#         parents=parents, \n#         help=\"Command 2 help\", \n#         formatter_class=SubcommandHelpFormatter\n#     )\n\nWe then create a new parser that will act as our subcommand, i.e. command_1 command_2 --args\n\n\n     parser.add_argument(\n#         \"--do-another-thing\",\n#         default=None,\n#         help=\"Whether to do the other thing\"\n#     )\n#     parser.set_defaults(func=subcommand_func)\n#     return parser\n\n# def subcommand_func(args):\n#     print(args)\n\nThen add a command and set the default func like before\n\n\n\n\nFinally the SubcommandHelpFormatter, which just helps make sure that when doing --help it actually looks sound (just trust me on this):\n\n\n\nutils.py\n\nimport argparse\n\nclass SubcommandHelpFormatter(argparse.RawDescriptionHelpFormatter):\n    \"\"\"\n    A custom formatter that will remove the usage line from the help message for subcommands.\n    \"\"\"\n\n    def _format_usage(self, usage, actions, groups, prefix):\n        usage = super()._format_usage(usage, actions, groups, prefix)\n        usage = usage.replace(\"<command> [<args>] \", \"\")\n        return usage\n\n\nNow we can do something like command_1 command_2 and the --help will show that command_1 has a subcommand and this can even be chained infinitely!\n\n!python3 __init__.py -h\n\nusage: Command 1 [-h] [--do-the-thing DO_THE_THING] {command_2} ...\n\nThe first command\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --do-the-thing DO_THE_THING\n                        Whether to do the thing\n\nsubcommands:\n  {command_2}\n    command_2           Command 2 help\n\n\n\n!python3 __init__.py command_2 -h\n\nusage: Command 1 command_2 [-h] [--do-another-thing DO_ANOTHER_THING]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --do-another-thing DO_ANOTHER_THING\n                        Whether to do the other thing"
  },
  {
    "objectID": "til/testing.html",
    "href": "til/testing.html",
    "title": "Mocking internals of a Python Script",
    "section": "",
    "text": "This will be split into two parts. The first contains the contents of some script.py file, which is the base template script we want to use:\n\nCodeCode + Explanation\n\n\n\ndef test_function(): \n    return 2\n\ndef main():\n    result = test_function()\n    with open(\"someFile.txt\", \"w\") as f:\n        f.write(str(result))\n        \nif __name__ == \"__main__\":\n    main()\n\n\n\n\ndef test_function(): \n    return 2\n\ndef main():\n    result = test_function()\n    with open(\"someFile.txt\", \"w\") as f:\n        f.write(str(result))\n        \nif __name__ == \"__main__\":\n    main()\n\n\ndef test_function(): \n    return 2\n\nThis is the function whose behavior we want to override during our mock\n\n\ndef main():\n    result = test_function()\n    with open(\"someFile.txt\", \"w\") as f:\n        f.write(str(result))\n\nThe main function is what we will call when running the python script. This will write a string representation of test_function() to a file.\n\n\nif __name__ == \"__main__\":\n    main()\n\nThis is a blocker to ensure that if anyone imports or calls this python script that it will be ran explicitly.\n\n\n\n\n\n\n\n\n\n\nFile Structure\n\n\n\nIt should be assumed that for the next part the structure of the code files are as such:\n\nbase_repository\n\nexample\n\nscript.py\n\ntests\n\ntest_script.py\n\n\n\n\n\n\nCodeCode + Explanation\n\n\n\nimport os\nimport sys\nimport unittest\nfrom unittest import mock\nSRC_DIRS = [\n    os.path.join(\n        os.path.dirname(__file__), \"example\"\n    )\n]\nsys.path.extend(SRC_DIRS)\nif SRC_DIRS is not None:\n    import script\ndef new_function():\n    return 0\n@mock.patch(\"script.test_function\", new_function)\nclass ExampleTester(unittest.TestCase):\n    def test_example(self):\n        script.main()\n        with open(\"someFile.txt\", \"r\") as f:\n            lines = f.read()\n        self.assertEquals(lines, \"0\")\n\n\n\n\nimport os\nimport sys\nimport unittest\nfrom unittest import mock\nSRC_DIRS = [\n    os.path.join(\n        os.path.dirname(__file__), \"example\"\n    )\n]\nsys.path.extend(SRC_DIRS)\nif SRC_DIRS is not None:\n    import script\ndef new_function():\n    return 0\n@mock.patch(\"script.test_function\", new_function)\nclass ExampleTester(unittest.TestCase):\n    def test_example(self):\n        script.main()\n        with open(\"someFile.txt\", \"r\") as f:\n            lines = f.read()\n        self.assertEquals(lines, \"0\")\n\n\nimport os\nimport sys\nimport unittest\nfrom unittest import mock\n\nThese are the imports we use\n\n\nSRC_DIRS = [\n    os.path.join(\n        os.path.dirname(__file__), \"example\"\n    )\n]\n\nThis is a list of directories that have our script source code relative to the current file. In this case the example directory.\n\n\nsys.path.extend(SRC_DIRS)\n\nWe add in our new SRC_DIRS to the sys.path which allows them to be imported through an import statement such as import script\n\n\nif SRC_DIRS is not None:\n    import script\n\nIf the file exists (this makes it modular) go ahead and import it\n\n\ndef new_function():\n    return 0\n\nThis is the new function we will use to replace the test_function in our python script\n\n\n@mock.patch(\"script.test_function\", new_function)\n\nThis uses unittest.mock to mokey-patch and override the original test_function in the existing module with the new one we just defined. Calling script.test_function() will call new_function() as a result\n\n\nclass ExampleTester(unittest.TestCase):\n    def test_example(self):\n        script.main()\n\nCalls the main function in our tester, but uses our new_function() when called\n\n\n        with open(\"someFile.txt\", \"r\") as f:\n            lines = f.read()\n        self.assertEquals(lines, \"0\")\n\nTests that the file which was written to has the properly mocked version of it, or 0"
  },
  {
    "objectID": "til/wraps.html",
    "href": "til/wraps.html",
    "title": "Undoing a wrapped function",
    "section": "",
    "text": "A few days ago there was an issue in Accelerate where a prepared model couldn’t be pickled. At first I thought it had to do with how in Accelerate we have a wrapper function that will make the model return FP32 outputs even on FP16."
  },
  {
    "objectID": "til/wraps.html#the-meat",
    "href": "til/wraps.html#the-meat",
    "title": "Undoing a wrapped function",
    "section": "The Meat",
    "text": "The Meat\nOkay so, let’s pretend we have the following situation in PyTorch:\n\nclass MathClass:\n    \"A super basic class that performs math\"\n    def __init__(self, a:int):\n        self.a = a\n        \n    def addition(self, b):\n        return self.a+b\n    \n    def subtraction(self, b):\n        return self.a-b\n\nLet’s then say that on the addition function of this class, I want to be able to wrap a function that will take the output of addition and divide it by two (logic wise it doesn’t make sense, but code wise it does).\nWe can use functools.wraps to do this:\n\nCodeCode + Explanation\n\n\n\nfrom functools import wraps\n\ndef addition_with_div(addition_func):\n    @wraps(addition_func)\n    def inner(*args, **kwargs):\n        result = addition_func(*args, **kwargs)\n        return result / 2\n    return inner\n\n\n\n\nfrom functools import wraps\n\ndef addition_with_div(addition_func):\n    @wraps(addition_func)\n    def inner(*args, **kwargs):\n        result = addition_func(*args, **kwargs)\n        return result / 2\n    return inner\n\n\n    @wraps(addition_func)\n\nA decorator that takes in some function and says that whatever function we have defined under it will be called after the inner function has finished.\n\n\n    def inner(*args, **kwargs):\n        result = addition_func(*args, **kwargs)\n        return result / 2\n\nInside the function that was decorated we then pass all the args to the original func and return its result divided by 2\n\n\n\n\nAnd finally use it:\n\nmath = MathClass(a=2)\nmath.addition = addition_with_div(math.addition)\n\nNow if we try and do math.addition we get:\n\nmath.addition(10)\n\n6.0\n\n\n2 + 10 divided by 2 like we expect! But then what did I have to solve? Pickling."
  },
  {
    "objectID": "til/wraps.html#pickling-the-beloved-destructor",
    "href": "til/wraps.html#pickling-the-beloved-destructor",
    "title": "Undoing a wrapped function",
    "section": "Pickling, the beloved destructor",
    "text": "Pickling, the beloved destructor\nLet’s try pickling this (and use torch because I’m lazy):\n\nimport torch\ntorch.save(math, \"mymaththing.pth\")\n\nPicklingError: Can't pickle <function MathClass.addition at 0x7f00c5a13700>: it's not the same object as __main__.MathClass.addition\n\n\nAs you can see, we get this weird pickling error. For the life of me I couldn’t figure out the why, until I finally did.\nTo save our object, I needed to remove my wrappers I had added, as they weren’t needed in the end result. Here’s how I did so:\n\nCodeCode + Explanation\n\n\n\nimport pickle\nfrom functools import update_wrapper\n\nclass AdditionWithDiv:\n    \"\"\"\n    Decorator which will perform addition then divide the result by two\n    \"\"\"\n    def __init__(self, addition_func):\n        self.addition_func = addition_func\n        update_wrapper(self, addition_func)\n    \n    def __call__(self, *args, **kwargs):\n        result = self.addition_func(*args, **kwargs)\n        return result / 2\n\n    def __getstate__(self):\n        raise pickle.PicklingError(\n            \"This wrapper cannot be pickled! Remove it before doing so\"\n        )\n        \naddition_with_div = AdditionWithDiv\n\n\n\n\nimport pickle\nfrom functools import update_wrapper\n\nclass AdditionWithDiv:\n    \"\"\"\n    Decorator which will perform addition then divide the result by two\n    \"\"\"\n    def __init__(self, addition_func):\n        self.addition_func = addition_func\n        update_wrapper(self, addition_func)\n    \n    def __call__(self, *args, **kwargs):\n        result = self.addition_func(*args, **kwargs)\n        return result / 2\n\n    def __getstate__(self):\n        raise pickle.PicklingError(\n            \"This wrapper cannot be pickled! Remove it before doing so\"\n        )\n        \naddition_with_div = AdditionWithDiv\n\n\n    def __init__(self, addition_func):\n        self.addition_func = addition_func\n        update_wrapper(self, addition_func)\n\nThe init function will first store the function and then call functools.update_wrapper and wrap self around addition_func. It’s the same thing that functools.wraps did for us, but we can make use of a custom class instead.\n\n\n    def __call__(self, *args, **kwargs):\n        result = self.addition_func(*args, **kwargs)\n        return result / 2\n\nHere we perform what the inner did earlier, get our result and divide by two\n\n\n    def __getstate__(self):\n        raise pickle.PicklingError(\n            \"This wrapper cannot be pickled! Remove it before doing so\"\n        )\n\nThis is a very important custom error that will occur when someone tries to pickle this object, letting them know that this shouldn’t happen and cannot be done. This will help not return that weird error as before that tells us nothing.\n\n\n\n\n\nmath = MathClass(a=2)\nmath.addition = addition_with_div(math.addition)\n\n\ntorch.save(math, \"mymaththing.pth\")\n\nPicklingError: This wrapper cannot be pickled! Remove it before doing so\n\n\nBetter, now to remove the wrapper:\n\nCodeCode + Explanation\n\n\n\nmath = MathClass(a=2)\nmath._original_addition = math.addition\nmath.addition = addition_with_div(math.addition)\n\naddition = getattr(math, \"addition\")\noriginal_addition = math.__dict__.pop(\"_original_addition\", None)\nif original_addition is not None:\n    while hasattr(addition, \"__wrapped__\"):\n        if addition != original_addition:\n            addition = addition.__wrapped__\n        else:\n            break\n    math.addition = addition\n\n\n\n\nmath = MathClass(a=2)\nmath._original_addition = math.addition\nmath.addition = addition_with_div(math.addition)\n\naddition = getattr(math, \"addition\")\noriginal_addition = math.__dict__.pop(\"_original_addition\", None)\nif original_addition is not None:\n    while hasattr(addition, \"__wrapped__\"):\n        if addition != original_addition:\n            addition = addition.__wrapped__\n        else:\n            break\n    math.addition = addition\n\n\nmath = MathClass(a=2)\nmath._original_addition = math.addition\nmath.addition = addition_with_div(math.addition)\n\nWe instantiate a new MathClass object and set a reference point to the original addition function we had before wrapping the function in our addition_with_div\n\n\naddition = math.addition\nmath.addition = addition_with_div(math.addition)\n\naddition = getattr(math, \"addition\")\noriginal_addition = math.__dict__.pop(\"_original_addition\", None)\n\nWe need to extract both the wrapped addition function and potentially if we have an _original_addition function if it exists.\n\n\n    while hasattr(addition, \"__wrapped__\"):\n        if addition != original_addition:\n            addition = addition.__wrapped__\n        else:\n            break\n\nWe traverse the layers of __wrapped__ functions (as this can go to multitudes such as d(c(b(a())))) and if the wrapped addition isn’t the same as the original, get that new reference and keep going\n\n\n    math.addition = addition\n\nFinally set the function to the found addition\n\n\n\n\nWe now have the old function again and can pickle it!\n\ntorch.save(math, \"mymaththing.pth\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Creating Nested CLI Commands with argparse\n\n\n\n\n\n\n\npython\n\n\ncli\n\n\n\n\nHow to create a command that goes a b c\n\n\n\n\n\n\nNov 21, 2022\n\n\n\n\n\n\n  \n\n\n\n\nUndoing a wrapped function\n\n\n\n\n\n\n\npython\n\n\n\n\nHow to pickle an object that may have been wrapped\n\n\n\n\n\n\nNov 20, 2022\n\n\n\n\n\n\n  \n\n\n\n\nMocking internals of a Python Script\n\n\n\n\n\n\n\npython\n\n\ntesting\n\n\n\n\nHow to test against a Python script when you need to change how __main__ behaves\n\n\n\n\n\n\nNov 19, 2022\n\n\n\n\n\n\n  \n\n\n\n\nThe Code Review Pyramid\n\n\n\n\n\n\n\ngeneral\n\n\n\n\nWhat to focus on during your code reviews\n\n\n\n\n\n\nNov 18, 2022\n\n\n\n\n\n\nNo matching items"
  }
]